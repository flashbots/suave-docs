---
title: Create Confidential Contracts
description: Realizing programmable privacy with confidential contracts on SUAVE that emit specific hints
keywords:
  - practical
  - suave
  - confidential
  - solidity
  - example
---

# Confidential contracts on SUAVE

We can extend [the contract we deployed in the previous guide](/how-to/create-contracts/deploy-custom) so that it emits the results of the simulation performed by the MEVM allowed to decrypt the confidential inputs.

```solidity
pragma solidity ^0.8.8;

import "../libraries/Suave.sol";

contract confidentialWithLogs {

    event SimResultEvent(
        uint64 egp
    );

    function fetchBidConfidentialBundleData() public returns (bytes memory) {
        require(Suave.isConfidential());
        
        bytes memory confidentialInputs = Suave.confidentialInputs();
        return abi.decode(confidentialInputs, (bytes));
    }

    // note: this enables the result of the confidential comput request (CCR) 
    // to be emitted on chain
    function emitSimResultEvent(uint64 egp) public {
        emit SimResultEvent(egp);
    }


    // note: because of confidential execution, 
    // you will not see your input as input to the function
    function helloWorld() external view returns (bytes memory) {
        // 0. ensure confidential execution
        require(Suave.isConfidential());

        // 1. fetch bundle data
        bytes memory bundleData = this.fetchBidConfidentialBundleData();

        // 2. sim bundle and get effective gas price
        uint64 effectiveGasPrice = Suave.simulateBundle(bundleData);

        // note: this enables the computation result to be emitted on chain
        return bytes.concat(this.emitSimResultEvent.selector, abi.encode(effectiveGasPrice));
    }
}
```
## Transaction flow

It is easiest to demonstrate how we expect data to flow in Rigil via a diagram. 

![Rigil transaction flow](/assets/rigil-tx-flow.svg)

Once a SUAPP has emitted the result of confidential computations, what happens? The next guide contains a more complete overview of [how data might flow if we replicate MEV-Share on SUAVE](/how-to/create-contracts/ofa).

## Confidential compute 

The function users would generally call - in this case `helloWorld()` - returns a _callback to another function_ which is intended to permute the state. If it returned the result, rather than this callback, it would expose the confidential data.

Confidential compute occurs through an [offchain function call](https://docs.soliditylang.org/en/latest/contracts.html#view-functions), signified in solidity by the `view` modifier.

Any MEVM specified by the user can use these view functions in conjunction with plaintext access to decrypted data to perform confidential computation. The result, and a signature of integrity, are propagated along with the initial transaction that contained the confidential compute request. 

Confidential data is propagated separately via the confidential data store, but other Kettles do not need the underlying data as they will trust any valid signature attesting to the integrity of the computation.