---
title: Send Transactions
description: Step-by-step walkthrough of how to send transactions on SUAVE
keywords:
  - practical
  - suave
  - transaction
  - example
---

# Send Transactions on SUAVE

If you followed the [previous guide](/how-to/run-suave), you will have SUAVE running locally, either in Docker or via the binaries themselves.

In either case, you can cause a series of transactions to occur by running:

```bash
go run suave/devenv/cmd/main.go
```

[[ðŸ”—source](https://github.com/flashbots/suave-geth/blob/main/suave/devenv/cmd/main.go)]  

This guide will show you how to craft such transactions yourself.

## RPC and SDK

In order to keep some data in transactions confidential, SUAVE JSON-RPC extends the usual Ethereum JSOPN-RPC methods in the following ways:

1. Two new fields - `IsConfidential` and `ExecutionNode` - have been added to the transaction arguments used in the `eth_sendTransaction` and `eth_call` methods.
2. One new optional argument - `confidential_data` - has been added to `eth_sendRawTransaction`, `eth_sendTransaction` and `eth_call` methods.
3. All RPCs that return transaction or receipt objects do so with type `SuaveTransaction`.

The [SUAVE SDK](https://github.com/flashbots/suave-geth/blob/main/suave/sdk/sdk.go) makes it easy to interact with the extended RPC and we will be using it in this guide.

## 1. Fund an account

First, setup everything needed to interact with your local development environment. 

Create a new file in `suave/devenv/cmd` called `transactions.go`:

```go
package main

import (
	"context"
	"crypto/ecdsa"
	"fmt"
	"math/big"
	"os"

	_ "embed"

	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/crypto"
	"github.com/ethereum/go-ethereum/rpc"
	"github.com/ethereum/go-ethereum/suave/sdk"
)

var (
    // This is the address we used when starting the MEVM
	exNodeEthAddr = common.HexToAddress("b5feafbdd752ad52afb7e1bd2e40432a485bbb7f")
	exNodeNetAddr = "http://localhost:8545"
	// This account is funded in both devenv networks
	// address: 0xBE69d72ca5f88aCba033a063dF5DBe43a4148De0
	fundedAccount = newPrivKeyFromHex(
    "91ab9a7e53c220e6210460b65a7a3bb2ca181412a8a7b43ff336b3df1737ce12"
  )
)

func main() {
    rpcClient, _ := rpc.Dial(exNodeNetAddr)
    // Use the SDK to create a new client by specifying the Eth Address of the MEVM
	mevmClt := sdk.NewClient(rpcClient, fundedAccount.priv, exNodeEthAddr)

	testAddr1 := generatePrivKey()

	fundBalance := big.NewInt(100000000)
	if err := fundAccount(mevmClt, testAddr1.Address(), fundBalance); err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		return
	}
	fmt.Printf("Funded test account: %s (%s)\n", testAddr1.Address().Hex(), fundBalance.String())
}

func fundAccount(clt *sdk.Client, to common.Address, value *big.Int) error {
	txn := &types.LegacyTx{
		Value: value,
		To:    &to,
	}
	result, err := clt.SendTransaction(txn)
	if err != nil {
		return err
	}
	_, err = result.Wait()
	if err != nil {
		return err
	}
	// check balance
	balance, err := clt.RPC().BalanceAt(context.Background(), to, nil)
	if err != nil {
		return err
	}
	if balance.Cmp(value) != 0 {
		return fmt.Errorf("failed to fund account")
	}
	return nil
}

// General types and methods we need for the above to work as we want it to, 
// nothing SUAVE specific
type privKey struct {
	priv *ecdsa.PrivateKey
}

func (p *privKey) Address() common.Address {
	return crypto.PubkeyToAddress(p.priv.PublicKey)
}

func newPrivKeyFromHex(hex string) *privKey {
	key, err := crypto.HexToECDSA(hex)
	if err != nil {
		panic(fmt.Sprintf("failed to parse private key: %v", err))
	}
	return &privKey{priv: key}
}

func generatePrivKey() *privKey {
	key, err := crypto.GenerateKey()
	if err != nil {
		panic(fmt.Sprintf("failed to generate private key: %v", err))
	}
	return &privKey{priv: key}
}
```

If you run the following from your terminal, you should now have one funded account:

```bash
go run suave/devenv/cmd/transactions.go
```

## 2. Deploy a Contract

We've written a number of example smart contracts to help get you started thinking about what's possible. For this guide, we'll stick to deploying one of these examples to keep things simple.

To see how to deploy your own smart contract, please see the [next guide](/how-to/create-contracts).