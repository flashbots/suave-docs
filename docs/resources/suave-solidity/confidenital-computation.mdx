---
title: Confidential Computation
description: test
---

Confidential computation is a key primitive in handling orderflow privately and securely. In SUAVE this is enabled by kettles (eventually running on TEEs) performing the compute offchain, but according to programs (smart contracts) written onchain. In this way offchain compute is not constrained by chain consensus.

## Confidential Compute Requests

From suave-spec

"Starting Point: The process initiates with a "Confidential Compute Request" directed towards the JsonRPC.

MEVM Execution: Upon receiving the request, the Json RPC triggers the MEVM (Modified Ethereum Virtual Machine) to run. MEVM execution can use multiple APIs depending on the context, with two possible paths:

Request to an External Domain: The MEVM can make API requests to external domains via Domain-Specific Services.
Request to the Confidential Datastore: The MEVM can make API requests directly to the "Confidential Datastore" to fetch or store data.
Suave Chain Interaction: Eventually, after processing the request, depending on the SUAPP, the MEVM takes the results and sends a SUAVE transaction.

Transaction Hash Output: Following the Suave transaction, a transaction hash is produced and returned to the request's originator, precisely like in the Ethereum process."

### Computing over Confidential Data

recordId is totally up to the SUAPP. For example in the private ofa example, if a searcher is submitting a backrun they need to include the recordID of the user txn in order for the suapp to include it, so the SUAPP emits it as a log on chain + details of the swap.
In my TEE example I store a private key in the conf store, so in order to get it to sign, I need to store the recordID in the contracts memory which ends up onchain. But no concern since its gated so only that SUAPP can access.

### Restricting Callbacks to Confidential Compute

"When u intialise the contract you pass it a secret key which is stored in confidential storage. This key with the local nonce is used to derive the next secret.

Hash of the present secret is in public(evm) storage.

Whenever restricted method is accessed the present secret needs to be provided - which is only accessable through confidential execution.

The implementation of ConfidentialControl: https://github.com/halo3mic/suave-playground/blob/9afe269ab2da983ca7314b68fcad00134712f4c0/contracts/blockad/lib/ConfidentialControl.sol
Example usage: https://github.com/halo3mic/suave-playground/blob/9afe269ab2da983ca7314b68fcad00134712f4c0/contracts/blockad/BlockAdV2.sol
Linking also the GIthub issue on SuaveGeth that describes this problem: https://github.com/flashbots/suave-geth/issues/121 (opens discussion on how to solve this in a better way)
Lmk if you have any questions or concerns about it!"