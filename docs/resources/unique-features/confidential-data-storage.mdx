---
title: Confidential Data Storage
description: How to leverage confidential data to your advantage when building on SUAVE
---

import List from '@site/src/components/List/List.tsx';

## Data Records

Confidential storage works via opaque identifiers, which are generated by Kettles when data is put in storage during offchain/confidential computation.

If another part of a Suapp needs to reference or interact with that confidential data, which occurs in the way defined by the relevant by the smart contract, then you need to share the unique identifier. You can see an example of this occurring in the [Private OFA Suapp](https://github.com/flashbots/suapp-examples/blob/main/examples/app-ofa-private/ofa-private.sol), where the relevant ID is emitted as a hint after a user submits a transaction.

However, it is possible that you can share IDs away from the SUAVE chain, via various different mechanisms depending on the context (text it to your friend)?

## Practical Example

First, it's worth understand what these DataRecords look like in the [`suave-std` library](https://github.com/flashbots/suave-std/blob/main/src/suavelib/Suave.sol).

```solidity
    type DataId is bytes16;

    struct DataRecord {
        DataId id;
        DataId salt;
        uint64 decryptionCondition;
        address[] allowedPeekers;
        address[] allowedStores;
        string version;
    }
```

Now, using the same [Private OFA Suapp](https://github.com/flashbots/suapp-examples/blob/main/examples/app-ofa-private/ofa-private.sol) example contract, we can see how these records are used and shared (when appropriate). The flow looks like this:

<List>

A user submits a transaction they wish to be included in the orderflow auction, calling the `newOrder()` function.

<div>

The contract defines logic which a Kettle can use to get the confidential data, simulate the results of including this transaction, and extract the hint to be shared with searchers.

```solidity
bytes memory bundleData = Suave.confidentialInputs();
uint64 egp = Suave.simulateBundle(bundleData);
bytes memory hint = Suave.extractHint(bundleData);
```
</div>

<div>

The contract then sets who can store and "peek" (i.e. retrieve) the data. In this case, both this Private OFA contract and the precompile contract deployed at the address `0x...43200001` are set as **allowedPeekers** and **allowedStores** (though you could have totally different addresses in these arrays in your own use case). If you consult the `suave-std` library, you'll see that the precompile deployed at that address is the `FILL_MEV_SHARE_BUNDLE`, which is what we require for this particular contract.

```solidity
address[] memory allowedList = new address[](2);
allowedList[0] = address(this);
allowedList[1] = 0x0000000000000000000000000000000043200001;
```

</div>

<div>

Then, we create the `dataRecord`. In this case, the `decryptionCondition` is set to `10` blocks from now (but `decryptionConditions` are to be deprecated soon) and the version is left as a blank string. Then, we write both the transaction itself, and the results from its simulation (in this case, the effective gas price after it is included) into the confidential store at different keys, which we will later use to match bundles and backruns in order to build profitable blocks.

```solidity
Suave.DataRecord memory dataRecord = Suave.newDataRecord(10, allowedList, allowedList, "");
Suave.confidentialStore(dataRecord.id, "mevshare:v0:ethBundles", bundleData);
Suave.confidentialStore(dataRecord.id, "mevshare:v0:ethBundleSimResults", abi.encode(egp));
```

</div>

<div>

The hint is not directly emitted on chain, as Confidential Compute Requests cannot directly change state, but rather is emitted as a callback once the order has been saved and the hint returned:

```solidity
return abi.encodeWithSelector(this.emitHint.selector, hintOrder);
```

</div>

Searchers can then use the information in this event to construct and submit valid backruns, which are matched against the original transactions via the `hintId`.

Matched transactions and backruns are bundled together via the `fillMevShareBundle()` precompile.

These bundles are sent to predefined off chain builders via the `submitBundleJsonRPC()` precompile.

</List>


