---
title: Block Building
description: How you can use SUAVE to build blocks on other chains
---

# Block Building

One of the unique features that SUAVE enables is block construction for other chains. Whether you're working on constructing transactions, creating bundles, or building blocks, this feature gives you the capability to interact with the latest blockchain state.

## The Basics

Bundles are one or more transactions that are grouped together and executed in the order they are provided and are the core unit of block building. If you're unfamiliar with bundles, and want to learn more, you can read [this document](https://docs.flashbots.net/flashbots-auction/advanced/understanding-bundles). 

## SUAVE Execution Namespace

SUAVE exposes several precompiles to help you with transaction simulation and block construction.

If your SUAPP is intended to produce blocks, be they partial or full, you'll first need to start a new builder session.

```solidity
function newBuilder() internal view returns (string memory)
```

This function starts a new builder instance within a Kettle. The basic idea is that you can use a session id to help with simulating transactions efficiently, so that you need not re-simulate transactions unnecessarily each time another transaction or bundle is received by your SUAPP. 

Once you do receive transactions or bundles, it is often the case that you need to simulate the effect they will have on the state of the target chain for which your SUAPP is building blocks. You'll often want to construct blocks in stages, as your SUAPP receive various different bundles and/or transactions from different users. This can be achieved with either of the below precompiles:

```solidity
function simulateBundle(bytes memory bundleData) internal view returns (uint64)
function simulateTransaction(string memory sessionid, bytes memory txn) internal view returns (SimulateTransactionResult memory)
```

If you're happy with the results of your simulation and wish to build a block based on the bundles/transactions you've received, you can use one more precompile:

```solidity
function buildEthBlock(BuildBlockArgs memory blockArgs, DataId dataId, string memory namespace) internal view returns (bytes memory, bytes memory)
```

As the name suggests, we only support building blocks on Ethereum L1 for now. This will change as SUAVE matures.

All of these functions utilize the SUAVE Execution Namespace. To understand more about this, please consult the [Execution Namespace specification](/technical/specs/rigil/mevm.md#suavex-namespace).

## Practical Implementation

Below is an example demonstrating the practical application of a block building session:

```solidity
function sessionExample(bytes memory subTxn, bytes memory subTxn2) public payable returns (bytes memory) {
    string memory id = Suave.newBuilder();

    Suave.SimulateTransactionResult memory sim1 = Suave.simulateTransaction(id, subTxn);
    require(sim1.success == true);
    require(sim1.logs.length == 1);

    // Simulate the same transaction again should fail due to nonce repetition
    Suave.SimulateTransactionResult memory sim2 = Suave.simulateTransaction(id, subTxn);
    require(sim2.success == false);

    // Simulate the transaction with the correct nonce
    Suave.SimulateTransactionResult memory sim3 = Suave.simulateTransaction(id, subTxn2);
    require(sim3.success == true);
    require(sim3.logs.length == 2);

    return abi.encodeWithSelector(this.emptyCallback.selector);
}
```

In this example, a new builder session is created, and multiple transactions are simulated with varying conditions to showcase the functionality of the SUAVE interface.

## Deep Dive

The below might be too much info andy. Maybe we just link to this spot in the code?

```
package builder

import (
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core"
	"github.com/ethereum/go-ethereum/core/state"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/core/vm"
	"github.com/ethereum/go-ethereum/params"
)

type builder struct {
	config   *builderConfig
	txns     []*types.Transaction
	receipts []*types.Receipt
	state    *state.StateDB
	gasPool  *core.GasPool
	gasUsed  *uint64
}

type builderConfig struct {
	preState *state.StateDB
	header   *types.Header
	config   *params.ChainConfig
	context  core.ChainContext
}

func newBuilder(config *builderConfig) *builder {
	gp := core.GasPool(config.header.GasLimit)
	var gasUsed uint64

	return &builder{
		config:  config,
		state:   config.preState.Copy(),
		gasPool: &gp,
		gasUsed: &gasUsed,
	}
}

func (b *builder) AddTransaction(txn *types.Transaction) (*types.SimulateTransactionResult, error) {
	dummyAuthor := common.Address{}

	vmConfig := vm.Config{
		NoBaseFee: true,
	}

	snap := b.state.Snapshot()

	b.state.SetTxContext(txn.Hash(), len(b.txns))
	receipt, err := core.ApplyTransaction(b.config.config, b.config.context, &dummyAuthor, b.gasPool, b.state, b.config.header, txn, b.gasUsed, vmConfig)
	if err != nil {
		b.state.RevertToSnapshot(snap)

		result := &types.SimulateTransactionResult{
			Success: false,
			Error:   err.Error(),
		}
		return result, nil
	}

	b.txns = append(b.txns, txn)
	b.receipts = append(b.receipts, receipt)

	result := &types.SimulateTransactionResult{
		Success: true,
		Logs:    []*types.SimulatedLog{},
	}
	for _, log := range receipt.Logs {
		result.Logs = append(result.Logs, &types.SimulatedLog{
			Addr:   log.Address,
			Topics: log.Topics,
			Data:   log.Data,
		})
	}

	return result, nil
}

    function newBuilder() internal view returns (string memory) {
        (bool success, bytes memory data) = NEW_BUILDER.staticcall(abi.encode());
        if (!success) {
            revert PeekerReverted(NEW_BUILDER, data);
        }

        return abi.decode(data, (string));
    }

```
