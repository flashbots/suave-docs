---
title: External Calls
description: Understanding the key primitives required to build great SUAPPs
keywords:
  - contract
  - deploy
  - suave
  - solidity
  - http
  - external
  - data
---

# Making external calls 

If you've followed along from the [previous tutorial](./confidential-store), you'll have deployed a simple contract with `onchain` and `offchain` functions, and extended it so that you can store a private key from another domain and use it to sign transactions after executing some offchain, confidential computation using SUAVE.

Building unique and powerful Suapps often requires one more key primitive (in addition to understanding on and offchain computations and how to use the confidential store). **Suapps can make arbitrary http requests to other domains, fetch data, and use that in their offchain computation**.

Let's walk through how to do this, first fetching balance information about USDC on Ethereum L1, and then by making a request to Chat GPT's completion endpoint.

## Fetching Balances from Ethereum 

Create a new contract in your `src` directory called `ExternalCall.sol`, and paste this into the file (making sure to update with your API key, or preferred RPC provider details):

```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.8;

import "suave-std/Suapp.sol";
import "suave-std/Context.sol";
import "suave-std/Gateway.sol";

interface ERC20 {
    function balanceOf(address) external view returns (uint256);
}

contract ExternalCall is Suapp {
    function onchain() external payable emitOffchainLogs {}

    event Balance(uint256 balance);

    function offchain() external returns (bytes memory) {
        string memory jsonRpc = Context.confidentialInputs();
        // targeting USDC contract on ETH L1
        Gateway gateway = new Gateway(jsonRpc, 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);
        ERC20 token = ERC20(address(gateway));

        // Fetching the balance for a Binance exchange account
        uint256 balance = token.balanceOf(0xDFd5293D8e347dFe59E90eFd55b2956a1343963d);
        emit Balance(balance);

        return abi.encodeWithSelector(this.onchain.selector);
    }
}
```

Follow the by-now familiar pattern of recompiling, deploying, and calling the offchain function using our `spell` tool:

```bash
forge build
```
```bash
suave-geth spell deploy ExternalCall.sol:ExternalCall
```
If you built `suave-geth` from source, you may need to specify the whole path:

```bash
./<path_to_suave-geth>/build/bin/suave-geth spell deploy ExternalCall.sol:ExternalCall
```
```bash
suave-geth spell conf-request <your_new_contract_address> 'offchain()' **TODO**
```

You should see the balance of the a Binance exchange account (because why not?) emitted as a log in your console:

**TODO**

Fetching blockchain data from domains beyond SUAVE is as easy as that! We're incredibly hyped to see what you build with this primitive. However, blockchain balances and other data is not the only kind of data you can fetch and use in your Suapps... 

## Using Chat GPT in a smart contract on SUAVE 

:::info

You will need your own ChatGPT API key for this section.

:::

Create a new contract in your `src` directory called `ChatContract.sol`, and paste this into the file:

```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.8;

import "suave-std/Suapp.sol";
import "suave-std/Context.sol";
import "suave-std/protocols/ChatGPT.sol";

contract ChatContract is Suapp {
    function onchain() external payable emitOffchainLogs {}

    event Response(string message);

    function offchain() external returns (bytes memory) {
        /* TODO: can Context.confidentialInputs() decode more than 1 value? If so, how? */
        string memory apiKey = Context.confidentialInputs(0);
        string[] memory messages = Context.confidentialInputs(1);
        ChatGPT chatGPT = new ChatGPT(apiKey);

        string memory response = chatGPT.complete(messages);
        emit Response(response);

        return abi.encodeWithSelector(this.onchain.selector);
    }
}
```

If you look under the hood at the [`ChatGPT.sol`](https://github.com/flashbots/suave-std/blob/main/src/protocols/ChatGPT.sol) file you are importing, you will see it uses the general-purpose `Suave.doHttpRequest()` precompile to achieve the magic of querying an LLM from within an otherwise-ordinary smart contract.

Recompile, deploy, and call the offchain function using our `spell` tool:

```bash
forge build
```
```bash
suave-geth spell deploy ChatContract.sol:ChatContract
```
```bash
suave-geth spell conf-request <your_new_contract_address> 'offchain()' **TODO**
```

You should see the response from ChatGPT printed in your console:

**TODO**

Congratulations! ðŸ’ƒ You now have all the tools you need to build powerful and unique Suapps which simply are not possible to build with other public blockchains. 

Feel free to post any Suapp you build on our [forum](https://collective.flashbots.net/c/suave/27) and we'll be happy to help you review interpolate, as well as invite you to our Developer Chat so you can see what others are building and share tips and best practices with the sharpest engineers we know.
